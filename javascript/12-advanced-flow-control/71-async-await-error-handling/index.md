






(https://wesbos.com/javascript/04-the-dom/built-in-and-custom-data-attributes)
    1.  [Data Attributes](https://wesbos.com/javascript/04-the-dom/built-in-and-custom-data-attributes/#data-attributes)
-   [Creating HTML<span class="videoNumber">Part 25</span>](https://wesbos.com/javascript/04-the-dom/creating-html)
    1.  [append method](https://wesbos.com/javascript/04-the-dom/creating-html/#append-method)
    2.  [insertAdjacentElement method](https://wesbos.com/javascript/04-the-dom/creating-html/#insertadjacentelement-method)
    3.  [Generating An Unordered List](https://wesbos.com/javascript/04-the-dom/creating-html/#generating-an-unordered-list)
-   [HTML from Strings and XSS<span class="videoNumber">Part 26</span>](https://wesbos.com/javascript/04-the-dom/html-from-strings-and-xss)
    1.  [document.createRange() and document.createFragment()](https://wesbos.com/javascript/04-the-dom/html-from-strings-and-xss/#documentcreaterange-and-documentcreatefragment)
    2.  [Security and Santization](https://wesbos.com/javascript/04-the-dom/html-from-strings-and-xss/#security-and-santization)
    3.  [XSS (Cross Site Scripting)](https://wesbos.com/javascript/04-the-dom/html-from-strings-and-xss/#xss-cross-site-scripting)
-   [Traversing and Removing Nodes<span class="videoNumber">Part 27</span>](https://wesbos.com/javascript/04-the-dom/traversing-and-removing-nodes)
    1.  [The difference between an Node and an Element](https://wesbos.com/javascript/04-the-dom/traversing-and-removing-nodes/#the-difference-between-an-node-and-an-element)
    2.  [Properties to work with Nodes and Elements](https://wesbos.com/javascript/04-the-dom/traversing-and-removing-nodes/#properties-to-work-with-nodes-and-elements)
    3.  [Removing Elements](https://wesbos.com/javascript/04-the-dom/traversing-and-removing-nodes/#removing-elements)
-   [Cardio<span class="videoNumber">Part 28</span>](https://wesbos.com/javascript/04-the-dom/cardio)
    1.  [closest method](https://wesbos.com/javascript/04-the-dom/cardio/#closest-method)




##### <span class="grit">Module 12 - Advanced Flow Control</span>

-   <a href="https://wesbos.com/javascript/12-advanced-flow-control/66-the-event-loop-and-callback-hell" class="currentModule">The Event Loop and Callback Hell<span class="videoNumber">Part 66</span></a>
-   <a href="https://wesbos.com/javascript/12-advanced-flow-control/67-promises" class="currentModule">Promises<span class="videoNumber">Part 67</span></a>
    1.  <a href="https://wesbos.com/javascript/12-advanced-flow-control/67-promises/#then-method" class="currentModule">.then() method</a>
    2.  <a href="https://wesbos.com/javascript/12-advanced-flow-control/67-promises/#promiseall" class="currentModule">Promise.all()</a>
    3.  <a href="https://wesbos.com/javascript/12-advanced-flow-control/67-promises/#promiserace" class="currentModule">Promise.race()</a>
-   <a href="https://wesbos.com/javascript/12-advanced-flow-control/68-promises-error-handling" class="currentModule">Promises - Error Handling<span class="videoNumber">Part 68</span></a>
    1.  <a href="https://wesbos.com/javascript/12-advanced-flow-control/68-promises-error-handling/#promiseallsettled" class="currentModule">Promise.allSettled()</a>
-   <a href="https://wesbos.com/javascript/12-advanced-flow-control/69-refactoring-callback-hell-to-promise-land" class="currentModule">Refactoring Callback Hell to Promise Land<span class="videoNumber">Part 69</span></a>
-   <a href="https://wesbos.com/javascript/12-advanced-flow-control/70-async-await" class="currentModule">Async/Await<span class="videoNumber">Part 70</span></a>
-   <a href="https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling" class="currentModule currentPage currentSection">Async/Await Error Handling<span class="videoNumber">Part 71</span></a>
    1.  <a href="https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/#handling-errors-with-higher-order-functions" class="currentModule currentPage">Handling Errors with Higher Order Functions</a>
-   <a href="https://wesbos.com/javascript/12-advanced-flow-control/72-async-await-prompt-ui" class="currentModule">Async/Await Prompt UI<span class="videoNumber">Part 72</span></a>
    1.  <a href="https://wesbos.com/javascript/12-advanced-flow-control/72-async-await-prompt-ui/#running-an-event-listener-only-once" class="currentModule">Running an Event Listener Only Once</a>
-   <a href="https://wesbos.com/javascript/12-advanced-flow-control/73-async-typer-ui-two-ways" class="currentModule">Async Typer UI - Two Ways<span class="videoNumber">Part 73</span></a>

##### <span class="grit">Module 13 - Ajax and Fetching Data</span>

-   [AJAX and APIs<span class="videoNumber">Part 74</span>](https://wesbos.com/javascript/13-ajax-and-fetching-data/74-ajax-and-apis)
    1.  [What is an API?](https://wesbos.com/javascript/13-ajax-and-fetching-data/74-ajax-and-apis/#what-is-an-api)
    2.  [JSON](https://wesbos.com/javascript/13-ajax-and-fetching-data/74-ajax-and-apis/#json)
    3.  [AJAX](https://wesbos.com/javascript/13-ajax-and-fetching-data/74-ajax-and-apis/#ajax)
    4.  [Public API list](https://wesbos.com/javascript/13-ajax-and-fetching-data/74-ajax-and-apis/#public-api-list)
-   [CORS and Recipes<span class="videoNumber">Part 75</span>](https://wesbos.com/javascript/13-ajax-and-fetching-data/75-cors-and-recipes)
    1.  [Query Parameters](https://wesbos.com/javascript/13-ajax-and-fetching-data/75-cors-and-recipes/#query-parameters)
    2.  [CORS](https://wesbos.com/javascript/13-ajax-and-fetching-data/75-cors-and-recipes/#cors)
        -   [What is CORS?](https://wesbos.com/javascript/13-ajax-and-fetching-data/75-cors-and-recipes/#what-is-cors)
        -   [CORS policy](https://wesbos.com/javascript/13-ajax-and-fetching-data/75-cors-and-recipes/#cors-policy)
    3.  [Babel](https://wesbos.com/javascript/13-ajax-and-fetching-data/75-cors-and-recipes/#babel)
    4.  [Browserlist](https://wesbos.com/javascript/13-ajax-and-fetching-data/75-cors-and-recipes/#browserlist)
    5.  [Proxy](https://wesbos.com/javascript/13-ajax-and-fetching-data/75-cors-and-recipes/#proxy)
-   [Dad Jokes<span class="videoNumber">Part 76</span>](https://wesbos.com/javascript/13-ajax-and-fetching-data/76-dad-jokes)
    1.  [Headers](https://wesbos.com/javascript/13-ajax-and-fetching-data/76-dad-jokes/#headers)
    2.  [Getting a Random Index](https://wesbos.com/javascript/13-ajax-and-fetching-data/76-dad-jokes/#getting-a-random-index)
    3.  [Loading State & CSS Loader](https://wesbos.com/javascript/13-ajax-and-fetching-data/76-dad-jokes/#loading-state--css-loader)
-   [Currency Converter<span class="videoNumber">Part 77</span>](https://wesbos.com/javascript/13-ajax-and-fetching-data/77-currency-converter)
    1.  [Caching the Rates](https://wesbos.com/javascript/13-ajax-and-fetching-data/77-currency-converter/#caching-the-rates)
    2.  [Converting](https://wesbos.com/javascript/13-ajax-and-fetching-data/77-currency-converter/#converting)
    3.  [Hooking Up The UI](https://wesbos.com/javascript/13-ajax-and-fetching-data/77-currency-converter/#hooking-up-the-ui)
        -   [Input Event on a Form](https://wesbos.com/javascript/13-ajax-and-fetching-data/77-currency-converter/#input-event-on-a-form)
        -   [Wiring up Handlers](https://wesbos.com/javascript/13-ajax-and-fetching-data/77-currency-converter/#wiring-up-handlers)
        -   [Formatting Currency using Number Format API](https://wesbos.com/javascript/13-ajax-and-fetching-data/77-currency-converter/#formatting-currency-using-number-format-api)

##### <span class="grit">Module 14 - ES Modules and Structuring Larger Apps</span>
##### <span class="grit">Module 15 - Final Round of Exercises</span>


<span class="grit">Async/Await Error Handling</span>
====================================================


JavaScript, Async/Await, Error HandlingEdit Post

We will talk about error handling strategies for `async await` in this lesson.

Because there is no `.then()` that we are chaining on with promises, it's not as easy as just chaining a `.catch()` onto the end of a promise chain in order to deal with what is going on.

We will cover 4 different ways that you can do error handling in `async await`, and then Wes will explain which approach he would use in which scenarios.

Go into our playground and copy the `async-await.html` file and rename it to `async-await-error-handling.html`.

Go and delete everything except for these two functions: `wait` and `makePizza`.

    <body>
    <script>
    function wait(ms = 0) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      })
    }

    function makePizza(toppings = []) {
      return new Promise(function (resolve, reject) {
        // reject if people try with pineapple
        if (toppings.includes('pineapple')) {
          reject('Seriously? Get out üçç');
        }

        const amountOfTimeToBake = 500 + (toppings.length * 200);

        // wait 1 second for the pizza to cook:
        setTimeout(function () {
          // when you are ready, you can resolve this promise
          resolve(`Here is your pizza üçï with the toppings ${toppings.join(' ')}`);
        }, amountOfTimeToBake);

        // if something went wrong, we can reject this promise;
      });
    }
    </script>
    </body>

In our `makePizza` function, we know that if it includes pineapple, it will reject because there is an error.

Go below the `makePizza` function declaration and we will make a function `go()`, which will make one pizza with the topping pineapple, and then we will call the function right below, like so üëá

    function go() {
      const pizza = makePizza(['pineapple']);
    }

    go();

If you refresh the page, you will see we get an error.

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1182px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:10.133333333333333%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhUlEQVQI10XHuw6CMABAUf7/s3QB1MRCbClgW6v4QAVEU00crokODmc40ZDn9EpxF4Ixz3hUJcE5Qnui0ZqmLPFKsdUFh7rC6wopJFW++r0ovjrv8VISva0lJDFhOuG1mP9lgsss5RzHtGnCbpkwOMO4cdycoTM1g7P01nBd1zz3DcdC8QGB+4/7Q9k8LgAAAABJRU5ErkJggg==');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/60a1f96792b7ba022ebdcdb7eb841923/7161f/1062.png" title="error - uncaught in promise in console" alt="error - uncaught in promise in console" class="gatsby-resp-image-image" /> </span>

If you try to log `pizza` within the `go` function, we don't get anything, we do not even get the error logged.

There are 4 ways that we could handle that.

The first 2 are with `try` and `catch`.

**try and catch** in JavaScript is basically what the name suggests. You try a bunch of stuff and you wrap it in a safety blanket and then if anything goes wrong, you catch the error and handle it.

You would use a try and catch inside the go function like so üëá

    async function go() {
      try{
        const pizza = await makePizza(['pineapple']);
        console.log(pizza);
      } catch(err) {
        console.log('Ohhhh nooo!');
        console.log(err);
      }
    }

Now if you refresh the page, you should see the following..

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1500px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:35.46666666666667%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABIUlEQVQY032QT0uDcACGPS07+WfMUgODaaehy38/g8Sf2nAbGzX6Ut2jQ52CBoPtM7V0Ze4yqdXJOQ2TIhjt5bk+7+FBgmAWhmE0nwcv88enYOo/T/3Z5/Lt6voOFQCltKrHZ5hk4ZJNbIDEcRxFr0mSxItF+eIHwcfy/eZ+tCMYtOYwikM3O7QKySbERAcX7ZJCXqXrNE2zLFv/LEmSPM9vhxOUB/uKe2jYLGgf6C4jm6xq0hqsAXcPOKRkI/nGVmlayA/j3SNAaV36tMPBHm8NOOucOfGqqkdqXlVrE7K3TUYFowZ6NXjB2H3eHXCtS9bsY3IXVwoItfu/PJxU6jolu2TRBpISxBoQa1iECH/ZIo8rdZ3VHUqBZR6i+c2f2l9nEdi/8x/sGAAAAABJRU5ErkJggg==');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/2c5ed83aa74b5fe92c8baef4b24861bf/aa440/1064.png" title="log the error caught inside catch block in console" alt="log the error caught inside catch block in console" class="gatsby-resp-image-image" /> </span>

What happened is any code inside of the try block is in the safe zone. It won't break the entire application if some of the code within the try errors out. Instead, it will just fail over to the `.catch()`.

That works with anything, not just async await.

If we tried calling a function that doesn't exist such as `window.doesNotExist()`, you will see we still get the errors for that.

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1140px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:21.6%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA6klEQVQI1xXG206DMAAAUP7/D3wxPi7GqduLZGHiZcgugO3aUqAXtzIm6ZSxjUtiFI3n6RinuonZW5Z/JEIdTu33T9d1v0opKaXggjGmlFqvVkJITGjMOOOSRknM+LGqjc2uurgDZ2Z4Pk567nbBC6IOts9HU2I6yHSQNaMjF99PsQ8pDAUg3INRgJJUH41UVxbYDF6S20nUt9HlGPQf8PUTHTjxzTMduuzKxj0LDh8hIIzyNJbZ+2edF01eNIYu2331JdZbRNmSxF6A5h7wXxGAYQDwwgdzD/wnWE5mAeUq06XeN7psd2X7B7NKyawkab16AAAAAElFTkSuQmCC');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/8b86f6b44c33715d8aa686485ef61a4b/b5cea/1065.png" title="TypeError: window.doesNotExist() error caught in console" alt="TypeError: window.doesNotExist() error caught in console" class="gatsby-resp-image-image" /> </span>

One downside to this is the syntax messes up the beautiful async await syntax because you have to wrap everything inside of the try and catch.

The benefit to that is you can have multiple promises.

For example, if we tried to make multiple pineapple pizzas, if either one failed, it would be caught by the same try/catch.

Another way we can do that is using what Wes refers to as "mix and match", meaning that we can use async/await but use the promise syntax for error handling.

Let's go and get rid of the try/catch we just added all together.

Instead, lets make a function `handleError`.

    function handleError(err) {
      console.log('Ohhhh nooo');
      console.log(err);
    }

Normally within function like `handleError` you would want to display the error in the UI to your user, send it off to an error handling service to log it, or something like that so you know what is going on, on the clients side.

In our case, we are just logging "Oh no!" and get the error.

What we can do is now chain a `.catch()` to the end of our `makePizza` call from within our async `go` function and pass it reference to `handleError`.

    async function go() {
      const pizza = await makePizza(['pineapple']).catch(handleError);
      console.log(pizza);
    }

Now when it runs, it will give us "oh nooo. Seriously? get out" and then logs undefined.

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1500px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:33.33333333333333%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABHklEQVQY032Q30vCUACF/RPudt1cJWVJvbl7M93aWOzeTTcpJSLYP9xLUQlavkXBaA+jMllDMHe54R5C6cfhe/04nFOIomg6ncZxHIZh+Bw9PD69vb5cXF6X9h2IqYxdiCjENkRUxFRAKxTSj4QxlqbpZDJJkmT8Pv6cza76gxKmReRsmKcVy9s7sivUK5u+oK7KPA9jLMsyxth8Puec3wzuZUyhSqDRkrXWpuZLTR8gB6gU1AhQCVCX5O8wxjjnt8ORjGix7lZNsmud75idLd0q62RNa0uGJxm+0mzLDedPGdZsod5Zd4NtP6jSQDHPivox1LviYU/Ue1DritrJv82YSAcUIJK/5QCVCMsg8rvcvxtJC5kqjcU2kCP84Atmx84jJdENtQAAAABJRU5ErkJggg==');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/da93911c15cdff5fbc1ae724de3f4441/aa440/1066.png" title="attaching catch block to the end of makePizza function" alt="attaching catch block to the end of makePizza function" class="gatsby-resp-image-image" /> </span>

We are sort of mix and matching to get the best of both worlds. We are using await to get the data from the promise instead of using the `.then()`. But we are still using the other syntax which is adding a `.catch()` onto the end of the function.

That approach is helpful when you want to handle the error at the time that you define the function, so you handle it inside of the function.

Sometimes you want to handle the error when you call the actual function.

If that is the case, we wouldn't handle it inside of the definition, but we would go down to where we call our async function and chain a `.catch()` onto there.

Look at the following example below üëá

    function handleError(err) {
      console.log('Ohhhh nooo');
      console.log(err);
    }

    async function go() {
      const pizza = await makePizza(['pineapple']).catch(handleError);
      console.log(pizza);
    }

    go.catch(handleEror);

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1136px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:15.2%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAApElEQVQI1z2O64qEMBSDff/3m1WxrbMzq71Ya61ufwjyLS3LBAIJSTinSSnxM024ZWGaZ87z5Loucs44Z3HOobXGWouzFm0s8mUQzwljzCcvumybMny930zaMD6/WbznOE4KpJQopWjblmEYEP9eKcnX40Hf97XTdR1CiPpIk9KBHEfMrOqF35wrC2KMleu6EkL4+C1GvPesIbBtW832fee+b/4AJSrgR1QaLVgAAAAASUVORK5CYII=');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/52bbeae733722168fc4514a464166804/f32b7/1067.png" title="catching error by passing a handleError function as callback in console" alt="catching error by passing a handleError function as callback in console" class="gatsby-resp-image-image" /> </span>

When you refresh the page you will see that the exact same thing just happened.

What is interesting about that is you can also catch things that are unrelated.

For example if within our `go()` function we call another function that does not yet exist, it will catch that error as well.

    async function go() {
      window.doesNotExist();
      const pizza = await makePizza(['pineapple']).catch(handleError);
      console.log(pizza);
    }

You might be saying to yourself "Wes, you said that `.then()` and `.catch()` can only be used on functions that return a promise, but here you are using a `.catch` on a function that does not return a promise".

`go()` doesn't return a promise, does it?

Let's check by returning pizza from the function as shown below.

    async function go() {
      const pizza = await makePizza(['pineapple']).catch(handleError);
      console.log(pizza);
      return pizza;
    }

    const result = go().catch(handleError);
    console.log(result);

What will the result be? Will we get the pizza? Will we get nothing?

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1152px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:23.466666666666665%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVQY001QWa6EMAzj/vcDIbE0LYUCRWLfQR4lem80H5aztI6T4DgOnOcpuK5LcN83hmGAUgplWSLLMlhrJWaQ1lIzWsMYA601iAjzPCPo+x5FUaCuaxGpqgrOOXnEvK4rpmnCsixf8EeuMf/mz/MgKKxF6z2INLz3eN/365DddF0n7tq2lT6Dh3OPuWkaYTay7zsCRQTSBKVImq5uRJQnxnEsq4RhiDzP5QScJ0mCKIqE0zQV5hOIoLEWjSNs64zzurBtmwjyTYdxFGF2O/7FDI7/a7/gzT7FIndOYj8I9AAAAABJRU5ErkJggg==');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/7b92af39f95123ca646c65314f208757/4ad3a/1069.png" title="function marked as async returns immediately returns a promise" alt="function marked as async returns immediately returns a promise" class="gatsby-resp-image-image" /> </span>

We get a promise! Whaaaaat?!

This is a very important thing about promises in `async await`.

When you mark a function as `async`, it will immediately return a promise to you. When a function is not marked with `async`, it is a regular function that will return the data that you want.

What is possible is that you can `await` `async` functions as well, because they in themselves are promises. So you could do something as shown in the code below.

    go()
      .then(result => {
        console.log(result);
      })
      .catch(handleError);

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1104px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:14.666666666666666%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnUlEQVQI101M2wqDMBTz/z/PIV5pbU917crUVrFDkIyeh7FACORWaCJ47yGkxHmeuO8b13XBWot5nplEGs5ZWPuEdQ5KKRhjOJum6dfLu2JUCvlUaQ33euG9LMiQUqJtW3Rdh6qqIITAMAysj7JEXdfo+x5N03BHjSPvCjKExRNS+iClxMzY9x0hBOa2bYgxIoTIuq4re//5cRx8+AWv/+AAaLu3jgAAAABJRU5ErkJggg==');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/f12da4e6e6321bd7fcd8f6cb3037d673/7388e/1070.png" title="attaching a then block after calling a async function" alt="attaching a then block after calling a async function" class="gatsby-resp-image-image" /> </span>

In that example it went straight to catch.

But if instead we were making a pepperoni pizza and modified the topping to be pepperoni instead of pineapple, then we would actually get access to the pepperoni pizza.

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1130px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:17.333333333333336%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiklEQVQI1y3LSxaDIAxAUfe/PG2tIEFQC8Qk+GNuT23v4M1eBda+Q1iDG8AQ81kKItbNQ2n9bFsA4FsIIcaIuKSEiLjv+3VdlfM+xHjwMk+j5FxKIWal9OBcb4wfx/W23ESEiIn4PxsAP815Mtb0EXHbtpRS3TRK61fXgbUiknNGRCJi5l+P4zt/APZLos+5LIZGAAAAAElFTkSuQmCC');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/ee0a9035eff2e1b9d33f74ee62a78022/d56e1/1071.png" title="async functions always return a promise automatically" alt="async functions always return a promise automatically" class="gatsby-resp-image-image" /> </span>

Asynchronous functions will always return a promise themselves, which means we can use the `.catch()` or the `.then()` syntax on the `async` functions if we want.

Why is that useful?

You often have a function with a few promises inside of it, but then you want to wait for that entire function to finish returning it's data. If that is the case, you use a `.then().catch()` or an `await()` on it.

Similarly, we do something as shown below üëá

    async function go() {
      const pizza = await makePizza(['pineapple']).catch(handleError);
      console.log(pizza);
      return pizza;
    }

    async function goGo() {
      const result = await go();
    }

    goGo();

If you refresh the page and run that, you will get an error.

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1182px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:10.4%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAiUlEQVQI1xXD3QqCMACAUd//heqqRWngbZHOmNP5N6elFprgzRcdOF4fRTzznEGnvP/LkrlzLNNI39R0TY2rSlxRYDNNnRmSWKGkos0z6jSl0RpnDJO1eJuUzP6ZZb/jKwRrGLJeArbblSbwqcQBcxTo8EQr77xSRZfE2DjCPRJcImml5GNyGAd+7WKQR1guyboAAAAASUVORK5CYII=');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/95d1623bd96eb8fda3ed476b7f63bbe6/7161f/1072.png" title="uncaught in promise error in console" alt="uncaught in promise error in console" class="gatsby-resp-image-image" /> </span>

How would you then handle that?

    goGo().catch(handleError);

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1108px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:14.399999999999999%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoklEQVQI1zWOiQqDMBAF/f//E/E+chgb64WaIuiUhHZhWHYHHi9qmpZxHKnqmn3fee6b67qw1iKlxBhD13WYwdAbwzAMSCmQQqCURGlFrzVCCM7zJKqbFqk1bdvxspbx/caPD0uShKIsieOYqqrI85zyd3uXpmkgy7LgfJGoKHKsaXDug3OO4zhCoG87zzPrujJNU9iebdvC/8+yLAHvnufhC5Vm35h3i/emAAAAAElFTkSuQmCC');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/caca42722975991c1f58c4ebed2aaca8/f680b/1073.png" title="chaining catch block after the async function" alt="chaining catch block after the async function" class="gatsby-resp-image-image" /> </span>

As you can seem by chaining a `.catch()` onto it, we handle the error.

You can nest promises as deep as you want and it is pretty common to have a good number of your functions marked as `async` and sort of have promises happening inside of promises. We will get into a lot more examples of that, so that might be a little confusing to you.

Let's bring the examples back to `go().catch(handleError)`.

That is the approach that Wes uses most often. It's sort of the best of both worlds. You can use the `await` like you want, and then you can catch them at call time.

The only difference would be calling `.catch()` inside of `go()`, like so üëá

    async function go() {
      const pizza = await makePizza(['pineapple']).catch(handleError);
    }

That is useful if you need to do something with the error inside the function like display a special modal at the time of definition, rather than at the time of call.

<span class="grit"><a href="#handling-errors-with-higher-order-functions" class="hash-anchor before"></a>Handling Errors with Higher Order Functions</span>
-----------------------------------------------------------------------------------------------------------------------------------------------------------

The last way to handle an error with async/await is called a **higher order function**.We have talked about this a couple of times now.

A higher order function is a function that returns another function.

The way it works is you go ahead and define all of your functions, just as if you were never to have any errors. (That is the way Wes typically likes to write his code, he will write them as `async` functions and he doesn't worry about error handling inside of those functions.)

When it comes time to calling that function, you have two options. You can catch it at run time like `go().catch(handleError)` or you can make a safe function with a higher order function.

Create a higher order function, `makeSafe` that takes in 2 parameters:

1.  The function that we want to make safe
2.  The function we want to be responsible for handling the error

What this function will do is it will return another function which then calls our original function and chains the `.catch()` onto the end.

This might not make sense to you, it didn't make sense to Wes for years, so don't sweat it if that's confusing.

    // make a safe function with a HOF
    function makeSafe(fn, errorHandler) {
      return function() {
        fn().catch(errorHandler);
      }
    }

If we just tried calling `go()` we would get an exception.

But if we instead call `go` by first wrapping it in the `makeSafe(go)` function, as shown below, it will handle the error gracefully.

    const safeGo = makeSafe(go, handleError);
    safeGo();

That is because `makeSafe` takes in a function, and then returns a new function that is just your original function with a `.catch()` tacked onto the end of it.

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:740px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:28.26666666666667%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyklEQVQY051Q0W7DIAzk//9t28M2aSGtFJzx0AiNFBNEQpKbcFup2x4m9aQT+AS27xRHhiGCMQQiQkoJ8zwj5/yHVf+PKsaIj0aD+h66PaCUgnvs+y6U+139Q7+eFeocMpxjhHBGnCbZ8FHUxqqUFTkvWJYLK6y1EoFzDp0xOByP6LoOum1B1OPTWjw9v+D17R2NbtFojWEYLhv+nuDHUfJiZkwp4ct70UII8H4ExyhOTqdBsg/M8ubmTNXM1nXFtm2SX/34oF/p8Q0ncNFDXbslLgAAAABJRU5ErkJggg==');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/0f634f35c37b9b670f5e61a1ae2d8727/50383/1074.png" title="makeSafe function in console" alt="makeSafe function in console" class="gatsby-resp-image-image" /> </span>

Now we have the function `safeGo` now that we can just call it without worrying about anything.

<span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:1120px"> <span class="gatsby-resp-image-background-image" style="padding-bottom:16.53333333333333%;position:relative;bottom:0;left:0;background-image:url(https://wesbos.com/javascript/12-advanced-flow-control/71-async-await-error-handling/'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgklEQVQI15WOwQrCMBBE8/+f10vTJul6qCiGNoFGtDnkyeakRwceLDvMzpqUEj4srOuVRYRHjJTypLWGc65jrWUcR0SEEALee4Zh6N48z0zT1OdSCialzCKB++3C632Sc+Y4DlT7vne2betouaK7GOOPr7laK0av1vMEGt/SD/+VZj4nwOQdt0BfPgAAAABJRU5ErkJggg==');background-size:cover;display:block"></span> <img src="https://wesbos.com/static/ec58905a3c46ae61b0cb1614edcdc467/f43e4/1075.png" title="execute function safeGo without worrying about anything" alt="execute function safeGo without worrying about anything" class="gatsby-resp-image-image" /> </span>

That works just fine.

Why would that be better than catching it like we were with `go().catch(handleError)` ?

More often than not, Wes has a function like `safeGo` or a function that does a specific task, and he uses that like 30 different times throughout his application. If he has to write the code to handle the error 30 different times, that is pretty cumbersome.

What you can do instead is make the safe function once (using `makeSafe` in our example), and then you can carry the safe function and run it whenever you want, knowing the error handler will have been attached on.

Those are a couple of different options you can use.

Wes most often catches errors at run time using `go().catch(handleError)`, and then when he is in Node/Express land, he tends to reach for a higher order function.

Find an issue with this post? Think you could clarify, update or add something?

All my posts are available to edit on Github. Any fix, little or small, is appreciated!

[Edit on Github](https://github.com/wesbos/wesbos/tree/master/src/javascript/12-advanced-flow-control/71-async-await-error-handling/71-async-await-error-handling.mdx)

[**‚Üê Prev**](https://wesbos.com/javascript/12-advanced-flow-control/70-async-await/)

Async/Await

[**Next ‚Üí**](https://wesbos.com/javascript/12-advanced-flow-control/72-async-await-prompt-ui/)

Async/Await Prompt UI

### <span class="highlight">Syntax Podcast</span>

Hold on ‚Äî I'm grabbin' the last one.
